{"version":3,"file":"redraw_wordcloud.min.js","sources":["../src/redraw_wordcloud.js"],"sourcesContent":["import { call as fetchMany } from 'core/ajax';\nimport WordCloud from 'mootimetertool_wordcloud/wordcloud2';\nimport {notifyFilterContentUpdated} from 'core_filters/events';\n\nconst observerRegistry = new Map();\n\nexport const init = (id) => {\n\n    if (!document.getElementById(id)) {\n        return;\n    }\n\n    // Initially getAnswers.\n    getAnswersAsync(id);\n\n    setTimeout(() => {\n        const intervalms = document.getElementById('mootimeterstate').dataset.refreshinterval;\n        const interval = setInterval(() => {\n            if (!document.getElementById(id)) {\n                clearInterval(interval);\n                return;\n            }\n            getAnswers(id);\n        }, intervalms);\n    }, 2000);\n\n    const mtmstate = document.getElementById('mootimeterstate');\n    mtmstate.setAttribute('data-wclastupdated', 0);\n};\n\n/**\n * This is because the execution should be finished befor proceeding.\n * @param {string} id\n */\nasync function getAnswersAsync(id) {\n    await getAnswers(id);\n}\n\n/**\n * Call to get all answers\n * @param {int} pageid\n * @param {int} lastupdated\n * @returns {array}\n */\nconst execGetAnswers = (\n    pageid,\n    lastupdated\n) => fetchMany([{\n    methodname: 'mootimetertool_wordcloud_get_answers',\n    args: {\n        pageid,\n        lastupdated\n    },\n}])[0];\n\n/**\n * Executes the call to get all answers.\n *\n * @param {string} id\n * @returns {mixed}\n */\nconst getAnswers = async (id) => {\n\n    if (!document.getElementById(id)) {\n        return;\n    }\n\n    var pageid = document.getElementById(id).dataset.pageid;\n\n    const mtmstate = document.getElementById('mootimeterstate');\n\n    // Early exit if there are no changes.\n    if (mtmstate.dataset.wclastupdated && mtmstate.dataset.wclastupdated == mtmstate.dataset.contentchangedat) {\n        return;\n    }\n\n    // Get the answer list.\n    const response = await execGetAnswers(pageid);\n\n    // Set wclastupdated.\n    mtmstate.setAttribute('data-wclastupdated', mtmstate.dataset.contentchangedat);\n\n    // Redraw wordcloud.\n    const container = document.getElementById(id);\n    if (!container) {\n        return;\n    }\n    container.setAttribute('data-answers', JSON.stringify(response.answerlist));\n    ensureObserver(container);\n    redrawwordcloud(container);\n\n    return;\n};\n\n/**\n * Redraw the wordcloud.\n * @param {HTMLElement} container\n */\nfunction redrawwordcloud(container) {\n    let mtmtcanvas = container;\n    let answers = JSON.parse(mtmtcanvas.dataset.answers);\n\n    WordCloud(mtmtcanvas, {\n        list: answers,\n        weightFactor: 24,\n        color: '#f98012',\n        fontFamily: 'OpenSans',\n        classes: 'filter_mathjaxloader_equation',\n    });\n}\n\n/**\n * Ensure MathJax is triggered when the wordcloud mutates.\n *\n * @param {HTMLElement} container\n */\nfunction ensureObserver(container) {\n    if (!container || observerRegistry.has(container.id)) {\n        return;\n    }\n\n    const observer = new MutationObserver((mutations) => {\n        if (!document.body.contains(container)) {\n            observer.disconnect();\n            observerRegistry.delete(container.id);\n            return;\n        }\n        let hasAddedNodes = false;\n        for (const mutation of mutations) {\n            if (mutation.addedNodes.length > 0) {\n                hasAddedNodes = true;\n                break;\n            }\n        }\n        if (hasAddedNodes) {\n            notifyFilterContentUpdated([container]);\n        }\n    });\n\n    observer.observe(container, {childList: true});\n    observerRegistry.set(container.id, observer);\n}\n"],"names":["observerRegistry","Map","id","document","getElementById","getAnswers","getAnswersAsync","setTimeout","intervalms","dataset","refreshinterval","interval","setInterval","clearInterval","setAttribute","async","pageid","mtmstate","wclastupdated","contentchangedat","response","lastupdated","methodname","args","execGetAnswers","container","JSON","stringify","answerlist","has","observer","MutationObserver","mutations","body","contains","disconnect","delete","hasAddedNodes","mutation","addedNodes","length","observe","childList","set","ensureObserver","mtmtcanvas","answers","parse","list","weightFactor","color","fontFamily","classes","redrawwordcloud"],"mappings":"6UAIMA,iBAAmB,IAAIC,kBAERC,SAEZC,SAASC,eAAeF,2BA0BFA,UACrBG,WAAWH,IAtBjBI,CAAgBJ,IAEhBK,YAAW,WACDC,WAAaL,SAASC,eAAe,mBAAmBK,QAAQC,gBAChEC,SAAWC,aAAY,KACpBT,SAASC,eAAeF,IAI7BG,WAAWH,IAHPW,cAAcF,YAInBH,cACJ,KAEcL,SAASC,eAAe,mBAChCU,aAAa,qBAAsB,UAkC1CT,WAAaU,MAAAA,SAEVZ,SAASC,eAAeF,eAIzBc,OAASb,SAASC,eAAeF,IAAIO,QAAQO,aAE3CC,SAAWd,SAASC,eAAe,sBAGrCa,SAASR,QAAQS,eAAiBD,SAASR,QAAQS,eAAiBD,SAASR,QAAQU,8BAKnFC,cAjCa,EACnBJ,OACAK,eACC,cAAU,CAAC,CACZC,WAAY,uCACZC,KAAM,CACFP,OAAAA,OACAK,YAAAA,gBAEJ,GAwBuBG,CAAeR,QAGtCC,SAASH,aAAa,qBAAsBG,SAASR,QAAQU,wBAGvDM,UAAYtB,SAASC,eAAeF,IACrCuB,YAGLA,UAAUX,aAAa,eAAgBY,KAAKC,UAAUP,SAASQ,sBA6B3CH,eACfA,WAAazB,iBAAiB6B,IAAIJ,UAAUvB,iBAI3C4B,SAAW,IAAIC,kBAAkBC,gBAC9B7B,SAAS8B,KAAKC,SAAST,kBACxBK,SAASK,kBACTnC,iBAAiBoC,OAAOX,UAAUvB,QAGlCmC,eAAgB,MACf,MAAMC,YAAYN,aACfM,SAASC,WAAWC,OAAS,EAAG,CAChCH,eAAgB,QAIpBA,sDAC2B,CAACZ,eAIpCK,SAASW,QAAQhB,UAAW,CAACiB,WAAW,IACxC1C,iBAAiB2C,IAAIlB,UAAUvB,GAAI4B,UApDnCc,CAAenB,oBAUMA,eACjBoB,WAAapB,UACbqB,QAAUpB,KAAKqB,MAAMF,WAAWpC,QAAQqC,gCAElCD,WAAY,CAClBG,KAAMF,QACNG,aAAc,GACdC,MAAO,UACPC,WAAY,WACZC,QAAS,kCAlBbC,CAAgB5B"}